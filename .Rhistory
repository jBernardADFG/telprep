viterbi <- viterbi(baum_welch, org_dat, best_detects)
baum_welch <- bwv(org_dat)
hmm_survival(best_detects)
hmm_survival <- function(best_detects, t_star=1, cl=0.95){
if (!requireNamespace("msm", quietly = TRUE)) {
stop("Package \"msm\" is needed for this function to work. Please install it.",
call. = FALSE)
}
msm_data <- org_dat_msm(best_detects, t_star = t_star)
fit_mod <- bwv(msm_data)
results <- extract_results(fit_mod)
v <- viterbi(fit_mod, msm_data, best_detects)
return(list(results=results, viterbi=v))
}
hmm_survival(best_detects)
hmm_survival(best_detects)
hmm_surv <- hmm_survival(best_detects)
hmm_survival(best_detects)
#' Use a Hidden Markov Model to determine the living status of the fish
#'
#' @description This function is a wrapper calling \code{\link{org_dat_msm}}, \code{\link{bwv}}, \code{\link{viterbi}}, and \code{\link{extract_results}}. See the help files for these functions for more information.
#' @param best_detects Output of \code{\link{get_locations}} or \code{\link{get_best_locations}}.
#' @param t_star The distance in km at which a fish is considered to have stayed in place between detection periods.
#' @param cl The desired confidence level.
#' @return Returns a list where $results provides a summary of the fit HMM and $viterbi returns a data.frame where the most likely path of survival states (i.e. the viterbi path) is added to the best_detects (1 means alive whereas 2 means expired). $viterbi can be input into \code{\link{make.plot}} or \code{\link{survival.plot}}.
#' @export
#' @examples
#' hmm_survival(best_detects)
hmm_survival <- function(best_detects, t_star=1, cl=0.95){
if (!requireNamespace("msm", quietly = TRUE)) {
stop("Package \"msm\" is needed for this function to work. Please install it.",
call. = FALSE)
}
msm_data <- org_dat_msm(best_detects, t_star = t_star)
fit_mod <- bwv(msm_data)
results <- extract_results(fit_mod)
v <- viterbi(fit_mod, msm_data, best_detects)
return(list(results=results, viterbi=v))
}
viterbi <- function(fit_mod, msm_data, best_detects){
if (!requireNamespace("msm", quietly = TRUE)) {
stop("Package \"msm\" is needed for this function to work. Please install it.",
call. = FALSE)
}
if (!requireNamespace("sfsmisc", quietly = TRUE)) {
stop("Package \"sfsmisc\" is needed for this function to work. Please install it.",
call. = FALSE)
}
v <- viterbi.msm(fit_mod)
v <- as.data.frame(cbind(TagID=msm_data$TagID, Channel=msm_data$Channel, Subject=msm_data$subject, FlightNum=msm_data$FlightNum, Fitted=v$fitted))
best_detects$Viterbi <- NA
for (i in 1:nrow(best_detects)){
best_detects$Viterbi[i] <- v$Fitted[v$TagID==best_detects$TagID[i] & v$Channel==best_detects$Channel[i] & v$FlightNum==best_detects$FlightNum[i]]
}
return(best_detects)
}
org_dat_msm <- function(best_detects, t_star=1){
if (!requireNamespace("sfsmisc", quietly = TRUE)) {
stop("Package \"sfsmisc\" is needed for this function to work. Please install it.",
call. = FALSE)
}
best_detects <- best_detects[order(best_detects$DateTime),]
flight_nums <- best_detects$FlightNum
med_times <- rep(NA, length(unique(flight_nums)))
for (i in unique(flight_nums)){
if(length(median(best_detects$DateTime[flight_nums==i]))>=1){
med_times[i] <- median(best_detects$DateTime[flight_nums==i])
}
}
med_times <- floor((med_times-min(med_times))/86400)+1
times_conversion_mat <- cbind(unique(flight_nums), med_times)
best_detects$Subject <- best_detects$Day <-  best_detects$Disp <- rep(NA, nrow(best_detects))
channels <- sort(unique(best_detects$Channel))
ids <- sort(unique(best_detects$TagID))
k <- 1
for (channelsi in channels){
for (idsi in ids){
if (sum(best_detects$Channel == channelsi & best_detects$TagID == idsi)>0){
best_detects$Subject[best_detects$Channel == channelsi & best_detects$TagID == idsi] <- k
k <- k + 1
}
}
}
for (i in unique(flight_nums)){
best_detects$Day[best_detects$FlightNum == times_conversion_mat[i,1]] <- times_conversion_mat[i,2]
}
flight_nums <- order(unique(best_detects$FlightNum))
subjects <- order(unique(best_detects$Subject))
for (flightsi in flight_nums[2:length(flight_nums)]){
for (subjectsi in subjects){
prev_dets <- best_detects[best_detects$FlightNum < flightsi & best_detects$Subject==subjectsi,]
if (nrow(prev_dets) > 0){
prev_lat <- prev_dets$Y[prev_dets$FlightNum == max(prev_dets$FlightNum)]
prev_lon <- prev_dets$X[prev_dets$FlightNum == max(prev_dets$FlightNum)]
}else{
prev_lat <- NA
prev_lon <- NA
}
this_lat <- best_detects$Y[best_detects$FlightNum==flightsi & best_detects$Subject==subjectsi]
this_lon <- best_detects$X[best_detects$FlightNum==flightsi & best_detects$Subject==subjectsi]
if (length(prev_lat[1])==0 || length(this_lat[1])==0){
best_detects$Disp[best_detects$FlightNum==flightsi & best_detects$Subject==subjectsi] <- NA
} else{
best_detects$Disp[best_detects$FlightNum==flightsi & best_detects$Subject==subjectsi] <- round( sqrt((prev_lon-this_lon)^2+(prev_lat-this_lat)^2)/1000,3)
}
}
}
r_df <- data.frame(best_detects$Channel, best_detects$TagID, best_detects$Subject, best_detects$DateTime, best_detects$Day, best_detects$Y, best_detects$X, best_detects$Disp, best_detects$Status, best_detects$FlightNum)
names(r_df) <- c("Channel", "TagID", "Subject", "DateTime", "Day", "Y", "X", "Displacement", "TagStatus", "FlightNum")
r_df$DisInd <- r_df$TagInd <- NA
for(i in 1:nrow(r_df)){
if (is.na(r_df$Displacement[i])){
r_df$DispInd[i] <- 3
}else if (r_df$Displacement[i] <= t_star){
r_df$DispInd[i] <- 2
}else{
r_df$DispInd[i] <- 3
}
if (r_df$TagStatus[i] == "Mort"){
r_df$TagInd[i] <- 2
}else{
r_df$TagInd[i] <- 3
}
}
fish <- sort(unique(r_df$Subject))
detect_periods <- sort(unique(r_df$Day))
df <- as.data.frame(sfsmisc::xy.grid(fish, detect_periods))
names(df) <- c("subject", "time")
df$obs1 <- 1
df$obs2 <- 1
for (i in 1:nrow(r_df)){
s <- r_df$Subject[i]
d <- r_df$Day[i]
obs1 <- r_df$DispInd[r_df$Subject==s & r_df$Day==d]
obs2 <- r_df$TagInd[r_df$Subject==s & r_df$Day==d]
df$obs1[df$subject==s & df$time==d] <- obs1
df$obs2[df$subject==s & df$time==d] <- obs2
}
df$obs <- cbind(obs1 = df$obs1, obs2 = df$obs2)
df$Channel <- df$TagID <- df$DateTime  <- df$Y<- df$X <- df$Displacement <- df$TagStatus <- df$FlightNum <- NA
for (i in 1:nrow(df)){
bool <- df$subject[i]==r_df$Subject & df$time[i]==r_df$Day
if (sum(bool)==1){
df$TagStatus[i] <- r_df$TagStatus[bool]
df$Channel[i] <- r_df$Channel[bool]
df$TagID[i] <- r_df$TagID[bool]
df$DateTime[i] <- r_df$DateTime[bool]
df$Y[i] <- r_df$Y[bool]
df$X[i] <- r_df$X[bool]
df$Displacement[i] <- r_df$Displacement[bool]
df$TagStatus[i] <- r_df$TagStatus[bool]
}
}
for (subject in unique(df$subject)){
df$TagID[df$subject == subject] <- na.omit(df$TagID[df$subject == subject])[1]
df$Channel[df$subject == subject] <- na.omit(df$Channel[df$subject == subject])[1]
df$FlightNum[df$subject == subject] <- rep(1:sum(df$subject==1))
}
return(df)
}
bwv <- function(msm_data){
if (!requireNamespace("msm", quietly = TRUE)) {
stop("Package \"msm\" is needed for this function to work. Please install it.",
call. = FALSE)
}
obs <- msm_data$obs
time <- msm_data$time
subject <- msm_data$subject
fit_mod <- msm::msm(obs ~ time,
subject=subject,
initprobs = c(0.999,0.001),
qmatrix = rbind(c(0.999,0.001),c(0,1)),
hmodel = list(hmmMV(hmmCat(prob=c(0.5,0.05,0.25)), # Alive - move
hmmCat(prob=c(0.5,0.05,0.25))), # Alive - mort-sig
hmmMV(hmmCat(prob=c(0.4,0.4,0)), # Dead - move
hmmCat(prob=c(0.3,0.25,0.05)))), # Dead -mort-sig
method="BFGS", control=list(maxit=15000))
return(fit_mod)
}
hmm_survival(best_detects)
#' Use a Hidden Markov Model to determine the living status of the fish
#'
#' @description This function is a wrapper calling \code{\link{org_dat_msm}}, \code{\link{bwv}}, \code{\link{viterbi}}, and \code{\link{extract_results}}. See the help files for these functions for more information.
#' @param best_detects Output of \code{\link{get_locations}} or \code{\link{get_best_locations}}.
#' @param t_star The distance in km at which a fish is considered to have stayed in place between detection periods.
#' @param cl The desired confidence level.
#' @return Returns a list where $results provides a summary of the fit HMM and $viterbi returns a data.frame where the most likely path of survival states (i.e. the viterbi path) is added to the best_detects (1 means alive whereas 2 means expired). $viterbi can be input into \code{\link{make.plot}} or \code{\link{survival.plot}}.
#' @export
#' @examples
#' hmm_survival(best_detects)
hmm_survival <- function(best_detects, t_star=1, cl=0.95){
if (!requireNamespace("msm", quietly = TRUE)) {
stop("Package \"msm\" is needed for this function to work. Please install it.",
call. = FALSE)
}
print("here")
msm_data <- org_dat_msm(best_detects, t_star = t_star)
print("here")
fit_mod <- bwv(msm_data)
print("here")
results <- extract_results(fit_mod)
print("here")
v <- viterbi(fit_mod, msm_data, best_detects)
print("here")
return(list(results=results, viterbi=v))
}
hmm_survival(best_detects)
make_plot(sldf, best_locations, darken=2.5, open_maps=T)
make_plot(sldf, best_locations, open_maps=T)
make_plot(sldf, all_locations, open_maps=T)
make_plot(sldf, best_detects, open_maps=T)
make_plot(sldf, best_detects, darken=2.5, open_maps=T)
library(OpenStreetMap)
par(mfrow=c(1,1))
org_dat
help("openmap")
make_plot(sldf, best_detects, type="stamen-watercolor", flight_num=1)
make_plot(sldf, best_detects, darken=2.5, open_maps=T)
make_plot(sldf, best_detects, flight_num=1)
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
}}
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
if (!requireNamespace("sp", quietly = TRUE)) {
stop("Package \"sp\" is needed for this function to work. Please install it.",
call. = FALSE)
}
if (!requireNamespace("raster", quietly = TRUE)) {
stop("Package \"raster\" is needed. Please install it.",
call. = FALSE)
}
if (is.na(flight_num[1])){
flight_num <- unique(detects$FlightNum)
}
if (is.na(channel[1])){
channel <- unique(detects$Channel)
}
if (is.na(tag_id[1])){
tag_id <- unique(detects$TagID)
}
par(mar=c(1,1,1,1))
if(isTRUE(open_maps)){
if (!requireNamespace("OpenStreetMap", quietly = TRUE)) {
stop("Package \"OpenStreetMap\" is needed when open_maps=T. Please install it.",
call. = FALSE)
}
if (!requireNamespace("plotwidgets", quietly = TRUE)) {
stop("Package \"plotwidgets\" is needed when open_maps=T. Please install it.",
call. = FALSE)
}
bbox <- sp::spTransform(sldf, sp::CRS("+init=epsg:4326"))@bbox
background <- suppressWarnings(OpenStreetMap::openmap(upperLeft=c(bbox[2,2],bbox[1,1]), lowerRight = c(bbox[2,1],bbox[1,2]),
type=type))
rgb <- background$tiles[[1]]$colorData
hsl <- plotwidgets::col2hsl(rgb)
hsl[3,] <- hsl[3,]/darken
background$tiles[[1]]$colorData <- plotwidgets::hsl2col(hsl)
plot(background, main=main,removeMargin=F)
}else{
plot(raster::crop(sldf,raster::extent(sldf)), main=main)
rect(sldf@bbox[1,1],sldf@bbox[2,1],sldf@bbox[1,2],sldf@bbox[2,2], col = "black")
}
if (is.null(detects$FlightNum)){
bd <- detects[is.element(detects$Channel, channel) & is.element(detects$TagID, tag_id),]
}else{
bd <- detects[is.element(detects$FlightNum, flight_num) & is.element(detects$Channel, channel) & is.element(detects$TagID, tag_id),]
}
x_vec <- c(sldf@bbox[1,1],sldf@bbox[1,1],sldf@bbox[1,2],sldf@bbox[1,2],sldf@bbox[1,1])
y_vec <- c(sldf@bbox[2,1],sldf@bbox[2,2],sldf@bbox[2,2],sldf@bbox[2,1],sldf@bbox[2,1])
bd <- bd[sp::point.in.polygon(bd$X, bd$Y, x_vec, y_vec)==1,]
c <- data.frame(bd$X, bd$Y)
sp <- sp::SpatialPoints(c, raster::crs(sldf))
new_sp <- sp::spTransform(sp, background[[1]][[1]]$projection)
bd$X <- new_sp@coords[,1]
bd$Y <- new_sp@coords[,2]
sldf <- sp::spTransform(sldf, background[[1]][[1]]$projection)
if (col_by_fish){
set.seed(3)
color_mat <- matrix(NA, nrow=100, ncol=100)
for(i in 1:100){
for(j in 1:100){
samp <- sample(550:650, 1)
color_mat[i,j] <- colors()[samp]
}
}
cols <- rep(NA, nrow(bd))
for(i in 1:nrow(bd)){
cols[i] <- color_mat[bd$Channel[i], bd$TagID[i]]
}
if(sum(names(detects)=="MortFlag")==0){
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=19, col=cols, cex=1, xlim=bbox(sldf)[1,],ylim=bbox(sldf)[2,])
}else{
plot_sym <- rep(19, nrow(bd))
plot_sym[bd$MortFlag=="Yes"] <- 4
print(plot_sym)
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=plot_sym, col=cols, cex=1, xlim=bbox(sldf)[1,],ylim=bbox(sldf)[2,])
}
}else if (viterbi==T){
plot_sym <- rep(19, nrow(bd))
plot_col_1 <- rep("red", nrow(bd))
plot_col_1[bd$Viterbi==2] <- "green4"
plot_col_2 <- rep("orange", nrow(bd))
plot_col_2[bd$Viterbi==2] <- "green3"
plot_col_3 <- rep("yellow", nrow(bd))
plot_col_3[bd$Viterbi==2] <- "green2"
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_1, cex=1)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_2, cex=0.5)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_3, cex=0.1)
}else{
if(sum(names(detects)=="MortFlag")==0){
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=19, col="red", cex=1)
points(bd$X, bd$Y, pch=19, col="orange", cex=0.5)
points(bd$X, bd$Y, pch=19, col="yellow", cex=0.1)
}else{
plot_sym <- rep(19, nrow(bd))
plot_col_1 <- rep("red", nrow(bd))
plot_col_1[bd$MortFlag=="Yes"] <- "green4"
plot_col_2 <- rep("orange", nrow(bd))
plot_col_2[bd$MortFlag=="Yes"] <- "green3"
plot_col_3 <- rep("yellow", nrow(bd))
plot_col_3[bd$MortFlag=="Yes"] <- "green2"
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_1, cex=1)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_2, cex=0.5)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_3, cex=0.1)
}
}
}}}}
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
stop("Package \"sp\" is needed for this function to work. Please install it.",
call. = FALSE)
if (!requireNamespace("sp", quietly = TRUE)) {
stop("Package \"sp\" is needed for this function to work. Please install it.",
call. = FALSE)
}
if (!requireNamespace("raster", quietly = TRUE)) {
stop("Package \"raster\" is needed. Please install it.",
call. = FALSE)
}
if (is.na(flight_num[1])){
flight_num <- unique(detects$FlightNum)
}
if (is.na(channel[1])){
channel <- unique(detects$Channel)
}
if (is.na(tag_id[1])){
tag_id <- unique(detects$TagID)
}
par(mar=c(1,1,1,1))
if(isTRUE(open_maps)){
if (!requireNamespace("OpenStreetMap", quietly = TRUE)) {
stop("Package \"OpenStreetMap\" is needed when open_maps=T. Please install it.",
call. = FALSE)
}
if (!requireNamespace("plotwidgets", quietly = TRUE)) {
stop("Package \"plotwidgets\" is needed when open_maps=T. Please install it.",
call. = FALSE)
}
bbox <- sp::spTransform(sldf, sp::CRS("+init=epsg:4326"))@bbox
background <- suppressWarnings(OpenStreetMap::openmap(upperLeft=c(bbox[2,2],bbox[1,1]), lowerRight = c(bbox[2,1],bbox[1,2]),
type=type))
rgb <- background$tiles[[1]]$colorData
hsl <- plotwidgets::col2hsl(rgb)
hsl[3,] <- hsl[3,]/darken
background$tiles[[1]]$colorData <- plotwidgets::hsl2col(hsl)
plot(background, main=main,removeMargin=F)
}else{
plot(raster::crop(sldf,raster::extent(sldf)), main=main)
rect(sldf@bbox[1,1],sldf@bbox[2,1],sldf@bbox[1,2],sldf@bbox[2,2], col = "black")
}
if (is.null(detects$FlightNum)){
bd <- detects[is.element(detects$Channel, channel) & is.element(detects$TagID, tag_id),]
}else{
bd <- detects[is.element(detects$FlightNum, flight_num) & is.element(detects$Channel, channel) & is.element(detects$TagID, tag_id),]
}
x_vec <- c(sldf@bbox[1,1],sldf@bbox[1,1],sldf@bbox[1,2],sldf@bbox[1,2],sldf@bbox[1,1])
y_vec <- c(sldf@bbox[2,1],sldf@bbox[2,2],sldf@bbox[2,2],sldf@bbox[2,1],sldf@bbox[2,1])
bd <- bd[sp::point.in.polygon(bd$X, bd$Y, x_vec, y_vec)==1,]
c <- data.frame(bd$X, bd$Y)
sp <- sp::SpatialPoints(c, raster::crs(sldf))
new_sp <- sp::spTransform(sp, background[[1]][[1]]$projection)
bd$X <- new_sp@coords[,1]
bd$Y <- new_sp@coords[,2]
sldf <- sp::spTransform(sldf, background[[1]][[1]]$projection)
}
}
}
}
}
}
}
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
}
if (!requireNamespace("sp", quietly = TRUE)) {
stop("Package \"sp\" is needed for this function to work. Please install it.",
call. = FALSE)
}
if (!requireNamespace("raster", quietly = TRUE)) {
stop("Package \"raster\" is needed. Please install it.",
call. = FALSE)
}
if (is.na(flight_num[1])){
flight_num <- unique(detects$FlightNum)
}
if (is.na(channel[1])){
channel <- unique(detects$Channel)
}
if (is.na(tag_id[1])){
tag_id <- unique(detects$TagID)
}
par(mar=c(1,1,1,1))
if(isTRUE(open_maps)){
if (!requireNamespace("OpenStreetMap", quietly = TRUE)) {
stop("Package \"OpenStreetMap\" is needed when open_maps=T. Please install it.",
call. = FALSE)
}
if (!requireNamespace("plotwidgets", quietly = TRUE)) {
stop("Package \"plotwidgets\" is needed when open_maps=T. Please install it.",
call. = FALSE)
}
bbox <- sp::spTransform(sldf, sp::CRS("+init=epsg:4326"))@bbox
background <- suppressWarnings(OpenStreetMap::openmap(upperLeft=c(bbox[2,2],bbox[1,1]), lowerRight = c(bbox[2,1],bbox[1,2]),
type=type))
rgb <- background$tiles[[1]]$colorData
hsl <- plotwidgets::col2hsl(rgb)
hsl[3,] <- hsl[3,]/darken
background$tiles[[1]]$colorData <- plotwidgets::hsl2col(hsl)
plot(background, main=main,removeMargin=F)
}else{
plot(raster::crop(sldf,raster::extent(sldf)), main=main)
rect(sldf@bbox[1,1],sldf@bbox[2,1],sldf@bbox[1,2],sldf@bbox[2,2], col = "black")
}
if (is.null(detects$FlightNum)){
bd <- detects[is.element(detects$Channel, channel) & is.element(detects$TagID, tag_id),]
}else{
bd <- detects[is.element(detects$FlightNum, flight_num) & is.element(detects$Channel, channel) & is.element(detects$TagID, tag_id),]
}
x_vec <- c(sldf@bbox[1,1],sldf@bbox[1,1],sldf@bbox[1,2],sldf@bbox[1,2],sldf@bbox[1,1])
y_vec <- c(sldf@bbox[2,1],sldf@bbox[2,2],sldf@bbox[2,2],sldf@bbox[2,1],sldf@bbox[2,1])
bd <- bd[sp::point.in.polygon(bd$X, bd$Y, x_vec, y_vec)==1,]
c <- data.frame(bd$X, bd$Y)
sp <- sp::SpatialPoints(c, raster::crs(sldf))
new_sp <- sp::spTransform(sp, background[[1]][[1]]$projection)
bd$X <- new_sp@coords[,1]
bd$Y <- new_sp@coords[,2]
sldf <- sp::spTransform(sldf, background[[1]][[1]]$projection)
if (col_by_fish){
set.seed(3)
color_mat <- matrix(NA, nrow=100, ncol=100)
for(i in 1:100){
for(j in 1:100){
samp <- sample(550:650, 1)
color_mat[i,j] <- colors()[samp]
}
}
cols <- rep(NA, nrow(bd))
for(i in 1:nrow(bd)){
cols[i] <- color_mat[bd$Channel[i], bd$TagID[i]]
}
if(sum(names(detects)=="MortFlag")==0){
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=19, col=cols, cex=1, xlim=bbox(sldf)[1,],ylim=bbox(sldf)[2,])
}else{
plot_sym <- rep(19, nrow(bd))
plot_sym[bd$MortFlag=="Yes"] <- 4
print(plot_sym)
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=plot_sym, col=cols, cex=1, xlim=bbox(sldf)[1,],ylim=bbox(sldf)[2,])
}
}else if (viterbi==T){
plot_sym <- rep(19, nrow(bd))
plot_col_1 <- rep("red", nrow(bd))
plot_col_1[bd$Viterbi==2] <- "green4"
plot_col_2 <- rep("orange", nrow(bd))
plot_col_2[bd$Viterbi==2] <- "green3"
plot_col_3 <- rep("yellow", nrow(bd))
plot_col_3[bd$Viterbi==2] <- "green2"
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_1, cex=1)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_2, cex=0.5)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_3, cex=0.1)
}else{
if(sum(names(detects)=="MortFlag")==0){
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=19, col="red", cex=1)
points(bd$X, bd$Y, pch=19, col="orange", cex=0.5)
points(bd$X, bd$Y, pch=19, col="yellow", cex=0.1)
}else{
plot_sym <- rep(19, nrow(bd))
plot_col_1 <- rep("red", nrow(bd))
plot_col_1[bd$MortFlag=="Yes"] <- "green4"
plot_col_2 <- rep("orange", nrow(bd))
plot_col_2[bd$MortFlag=="Yes"] <- "green3"
plot_col_3 <- rep("yellow", nrow(bd))
plot_col_3[bd$MortFlag=="Yes"] <- "green2"
lines(raster::crop(sldf,raster::extent(sldf)), col="blue4", lwd=2)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_1, cex=1)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_2, cex=0.5)
points(bd$X, bd$Y, pch=plot_sym, col=plot_col_3, cex=0.1)
}
}
make_plot <- function(sldf, detects, open_maps=F, type="bing", darken=1, col_by_fish=F, flight_num=NA, channel=NA, tag_id=NA, viterbi=F, main="", ...){
