# Ls <- Lines(list(L1,L2,L3,L4,L5,L6), ID="a")
# SL <- SpatialLines(list(Ls))
# SLDF <- SpatialLinesDataFrame(SL, data.frame(Z="river", row.names = "a"))
#
# crs(SLDF) <- sldf@proj4string
# save(SLDF, file="S:/Jordy/Yukon River burbot radiotelemetry/R Code/data/SLDF.xlsx")
load("S:/Jordy/Yukon River burbot radiotelemetry/R Code/data/SLDF.xlsx")
# -------------------------------------------------------------------------
# Read in the aerial data
library(readxl)
telemetryData <- as.data.frame(read_excel("S:/Jordy/Yukon River burbot radiotelemetry/R Code/data/telemetryData.xlsx"))
# -------------------------------------------------------------------------
# Read in and cleanup the tagging data -- The tagging data will need to be reformatted once Lisa gets me the new version
taggingData <- read_excel("S:/Jordy/Yukon River burbot radiotelemetry/R Code/data/taggingData.xlsx")
get.id <- function(frequency, code){
id <- rep(NA, length(frequency))
for (i in 1:length(frequency)){
l <- nchar(frequency[i])
id1 <- substr(frequency[i], 5, 6)
if (nchar(id1)==1){
id1 <- paste(id1,"0", sep="")
}
id2 <- code[i]
id[i] <- paste(id1, id2, sep="-")
}
return(id)
}
frequency <- taggingData$frequency
code <- taggingData$code
id <- get.id(frequency, code)
taggingData <- data.frame(id=id, lat=taggingData$lat, lon=taggingData$lon, period=0, loc=taggingData$loc)
for (i in 1:nrow(taggingData)){
if(taggingData$lon[i] > 0){
taggingData$lon[i] <- -taggingData$lon[i]
}
}
# -------------------------------------------------------------------------
# Combine the tagging and aerial data
allData <- rbind(taggingData, telemetryData)
sp <- SpatialPoints(allData[,c(3,2)])
latlong <- "+init=epsg:4326"  # WGS 84
crs(sp) <- CRS(latlong)
sp <- spTransform(sp, sldf3@proj4string)
allData$lat <- sp@coords[,2]
allData$lon <- sp@coords[,1]
# Create a rivernetwork object for use in riverdist -- I'm modifying line2network() so that I don't need to export a shapefile
# l2n <- function(sldf, layer, tolerance = 100, reproject = NULL,
#           supplyprojection = NULL)
# {
#   sp <- sldf
#   if (class(sp) != "SpatialLinesDataFrame")
#     stop("Specified shapefile is not a linear feature.")
#   if (is.na(sp@proj4string@projargs) & !is.null(supplyprojection))
#     sp@proj4string@projargs <- supplyprojection
#   if (is.na(sp@proj4string@projargs))
#     stop("Shapefile projection information is missing.  Use supplyprojection= to specify a Proj.4 projection to use.  If the input shapefile is in WGS84 geographic (long-lat) coordinates, this will be +proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0 (in double-quotes).  If so, it must also be reprojected using reproject=.")
#   proj4 <- strsplit(sp@proj4string@projargs, split = " ")
#   projected <- sp::is.projected(sp)
#   if (is.null(reproject) & !projected)
#     stop("Distances can only be computed from a projected coordinate system.  Use reproject= to specify a Proj.4 projection to use.")
#   if (!is.null(reproject)) {
#     sp <- sp::spTransform(sp, sp::CRS(reproject))
#     proj4 <- strsplit(sp@proj4string@projargs, split = " ")
#   }
#   units <- "unknown"
#   for (i in 1:length(proj4[[1]])) {
#     if (proj4[[1]][i] != "") {
#       proj4arg <- strsplit(proj4[[1]][i], split = "=")
#       if (proj4arg[[1]][1] == "+units") {
#         units <- proj4arg[[1]][2]
#         cat("\n", "Units:", proj4arg[[1]][2],
#             "\n")
#       }
#     }
#   }
#   if (length(sp@lines) > 1) {
#     sp_line <- NA
#     sp_seg <- NA
#     lines <- list()
#     j <- 1
#     for (i in 1:length(sp@lines)) {
#       for (k in 1:length(sp@lines[i][[1]]@Lines)) {
#         lines[[j]] <- sp@lines[i][[1]]@Lines[[k]]@coords
#         sp_line[j] <- i
#         sp_seg[j] <- k
#         j <- j + 1
#       }
#     }
#   }
#   if (length(sp@lines) == 1) {
#     lines <- sp@lines[1][[1]]@Lines
#     length <- length(lines)
#     lines.new <- list()
#     for (i in 1:length) {
#       lines.new[[i]] <- lines[[i]]@coords
#     }
#     lines <- lines.new
#     sp_line <- rep(1, length)
#     sp_seg <- 1:length
#   }
#   length <- length(lines)
#   rivID <- 1:length
#   lineID <- data.frame(rivID, sp_line, sp_seg)
#   connections <- calculateconnections(lines = lines, tolerance = tolerance)
#   if (any(connections %in% 5:6))
#     braided <- TRUE
#   lengths <- rep(NA, length)
#   for (i in 1:length) {
#     lengths[i] <- pdisttot(lines[[i]])
#   }
#   names <- rep(NA, length)
#   mouth.seg <- NA
#   mouth.vert <- NA
#   mouth <- list(mouth.seg, mouth.vert)
#   names(mouth) <- c("mouth.seg", "mouth.vert")
#   sequenced <- FALSE
#   braided <- NA
#   cumuldist <- list()
#   for (i in 1:length) {
#     xy <- lines[[i]]
#     n <- dim(xy)[1]
#     cumuldist[[i]] <- c(0, cumsum(sqrt(((xy[1:(n - 1), 1] -
#                                            xy[2:n, 1])^2) + ((xy[1:(n - 1), 2] - xy[2:n, 2])^2))))
#   }
#   out.names <- c("sp", "lineID", "lines",
#                  "connections", "lengths", "names",
#                  "mouth", "sequenced", "tolerance",
#                  "units", "braided", "cumuldist")
#   out <- list(sp, lineID, lines, connections, lengths, names,
#               mouth, sequenced, tolerance, units, braided, cumuldist)
#   names(out) <- out.names
#   class(out) <- "rivernetwork"
#   length1 <- length(out$lengths)
#   suppressMessages(out <- removeduplicates(out))
#   length2 <- length(out$lengths)
#   if (length2 < length1)
#     cat("\n", "Removed", length1 - length2, "duplicate segments.",
#         "\n")
#   suppressMessages(out <- removemicrosegs(out))
#   length3 <- length(out$lengths)
#   if (length3 < length2)
#     cat("\n", "Removed", length2 - length3, "segments with lengths shorter than the connectivity tolerance.",
#         "\n")
#   return(out)
# }
#
# l2n <- l2n(SLDF, tolerance = 1000)
# riverNetwork <- cleanup(l2n)
# save(riverNetwork, file="S:/Jordy/Yukon River burbot radiotelemetry/R Code/data/rivernetwork.xlsx")
load("S:/Jordy/Yukon River burbot radiotelemetry/R Code/data/rivernetwork.xlsx")
# -------------------------------------------------------------------------
allData <- allData[-865,]  # Removing the funny detection that occurred away from the rivernetwork
for(fish in unique(allData$id)){
if(nrow(allData[allData$id==fish,])<=1){
allData <- allData[allData$id!=fish,] # remove the fish that were detected less than or equal to one time
}
}
# -------------------------------------------------------------------------
# get the segment and vertex associated with each detection
segVert <- xy2segvert(x=allData$lon, y=allData$lat, rivers=riverNetwork)
allData$seg <- segVert$seg
allData$vert <- segVert$vert
allData$snapdist <- segVert$snapdist
}
# -------------------------------------------------------------------------
# minimum observed home range for each individual
{
library(riverdist)
ranges <- with(allData, homerange(unique=id, survey=period, seg=seg, vert=vert, rivers=riverNetwork))
rkm <- data.frame(id=ranges$ranges[,1],range=ranges$ranges[,2]/1000)
rkm
}
save(sldf, file="D:/Jordy/tyersData/sldf.Rdata")
riverNetwork
save(riverNetwork, file="D:/Jordy/tyersData/riverNetwork.Rdata")
load("D:/Jordy/tyersData/riverNetwork.Rdata")
{
library(OpenStreetMap)
plot.homerange <- function(x,SLDF,cumulative=FALSE,lwd=3,maxlwd=10,col=4,pch=21,label=FALSE,main=NULL,...) {
if(is.null(x$survey) & cumulative) warning("Argument survey= will ensure points are chronological order. Entry order used.")
if(is.null(main)) mains <- names(x$subseg_n)
if(length(main)==1) mains <- rep(main,length(x$subseg_n))
if(length(main)>1)  mains <- main
proj4 <- SLDF@proj4string
maxlwds <- max(unlist(x$subseg_n),na.rm=T)
lwdfactor <- ifelse(maxlwds==1,0,(maxlwd-lwd)/(maxlwds-1))
temp<-spTransform(SLDF, CRS("+init=epsg:4326"))
bbox <- temp@bbox
suppressWarnings(base_map<-OpenStreetMap::openmap(upperLeft=c(bbox[2,2],bbox[1,1]), lowerRight = c(bbox[2,1],bbox[1,2]),
type="bing"))
plot(base_map, removeMargin=F)
SLDF <- spTransform(SLDF, base_map[[1]][[1]]$projection)
lines(SLDF)
for(i in 1:length(x$subseg_n)) { # iterating through each fish
for(j in 1:length(x$subseg_n[[i]])) { # iterating through each riverline
a <- x$subseg_n[[i]][[j]] # vertexes of the riverline
if(!cumulative) a <- 1*(a>0)
n <- length(a)
firsts <- c(1,(which(a[-n]!=a[-1])+1))
lasts <- c(which(a[-n]!=a[-1]),n)
denses <- a[firsts]
for(k in 1:length(denses)) {
if(denses[k]>0){
if(!is.null(dim(x$rivers$lines[[j]][(firsts[k]:lasts[k]),]))){
pts <- x$rivers$lines[[j]][(firsts[k]:lasts[k]),]
spts <- SpatialPoints(pts, proj4)
new_spts <- spTransform(spts, base_map[[1]][[1]]$projection)
new_df <- new_spts@coords
lines(new_df[,1], new_df[,2],lwd=7,col=col) # plotting the line
}
}
}
}
}
}
par(mfrow=c(1,1))
}
{
rusFish <- allData$id[allData$loc=="RUS" & allData$period==0]
rusData <- allData[is.element(allData$id, rusFish),]
rusSegVert <- xy2segvert(x=rusData$lon, y=rusData$lat, rivers=riverNetwork)
rusData$seg <- rusSegVert$seg
rusData$vert <- rusSegVert$vert
rusData$snapdist <- rusSegVert$snapdist
rusRanges <- with(rusData, homerange(unique=id, survey=period, seg=seg, vert=vert, rivers=riverNetwork))
plot.homerange(rusRanges, sldf)
load("S:/Jordy/Yukon River burbot radiotelemetry/R Code/data/proj.Rdata")
pts <- data.frame(rusData[rusData$period==0,]$lon, rusData[rusData$period==0,]$lat)
spts <- SpatialPoints(pts, sldf@proj4string)
new_spts <- spTransform(spts, proj)
points(new_spts@coords, pch=19, cex=2, col="black")
points(new_spts@coords, pch=19, cex=1, col="red")
}
{
galFish <- allData$id[allData$loc=="GAL" & allData$period==0]
galData <- allData[is.element(allData$id, galFish),]
galSegVert <- xy2segvert(x=galData$lon, y=galData$lat, rivers=riverNetwork)
galData$seg <- galSegVert$seg
galData$vert <- galSegVert$vert
galData$snapdist <- galSegVert$snapdist
galRanges <- with(galData, homerange(unique=id, survey=period, seg=seg, vert=vert, rivers=riverNetwork))
plot.homerange(galRanges, sldf)
pts <- data.frame(galData[galData$period==0,]$lon, galData[galData$period==0,]$lat)
spts <- SpatialPoints(pts, sldf@proj4string)
new_spts <- spTransform(spts, proj)
points(new_spts@coords, pch=19, cex=2, col="black")
points(new_spts@coords, pch=19, cex=1, col="red")
}
{
lauFish <- allData$id[allData$loc=="LAU" & allData$period==0]
lauData <- allData[is.element(allData$id, lauFish),]
lauSegVert <- xy2segvert(x=lauData$lon, y=lauData$lat, rivers=riverNetwork)
lauData$seg <- lauSegVert$seg
lauData$vert <- lauSegVert$vert
lauData$snapdist <- lauSegVert$snapdist
lauRanges <- with(lauData, homerange(unique=id, survey=period, seg=seg, vert=vert, rivers=riverNetwork))
plot.homerange(lauRanges, sldf)
pts <- data.frame(lauData[lauData$period==0,]$lon, lauData[lauData$period==0,]$lat)
spts <- SpatialPoints(pts, sldf@proj4string)
new_spts <- spTransform(spts, proj)
points(new_spts@coords, pch=19, cex=2, col="black")
points(new_spts@coords, pch=19, cex=1, col="red")
}
{
cirFish <- allData$id[allData$loc=="CIR" & allData$period==0]
cirData <- allData[is.element(allData$id, cirFish),]
cirSegVert <- xy2segvert(x=cirData$lon, y=cirData$lat, rivers=riverNetwork)
cirData$seg <- cirSegVert$seg
cirData$vert <- cirSegVert$vert
cirData$snapdist <- cirSegVert$snapdist
cirRanges <- with(cirData, homerange(unique=id, survey=period, seg=seg, vert=vert, rivers=riverNetwork))
plot.homerange(cirRanges,sldf)
pts <- data.frame(cirData[cirData$period==0,]$lon, cirData[cirData$period==0,]$lat)
spts <- SpatialPoints(pts, sldf@proj4string)
new_spts <- spTransform(spts, proj)
points(new_spts@coords, pch=19, cex=2, col="black")
points(new_spts@coords, pch=19, cex=1, col="red")
}
# -------------------------------------------------------------------------
# mean proportion of homerange overlap by tagging location -- think this looks good -- we'll need to document the methods
{
homerangeOverlap <- homerangeoverlap(ranges)
prop_both <- homerangeOverlap$prop_both
prop_both
homerangeoverlapmat <- matrix(NA, nrow=4, ncol=4)
rusIDS <- taggingData$id[taggingData$loc=="RUS"]
cirIDS <- taggingData$id[taggingData$loc=="CIR"]
lauIDS <- taggingData$id[taggingData$loc=="LAU"]
galIDS <- taggingData$id[taggingData$loc=="GAL"]
get.props.same <- function(ids){
temp <- c()
k <- 1
mat <- prop_both[is.element(rownames(prop_both), ids), is.element(colnames(prop_both), ids)]
for (i in 1:nrow(mat)){
for (j in 1:ncol(mat)){
if(j>i){
temp[k] <- mat[i,j]
k <- k + 1
}
}
}
temp <- temp[!is.nan(temp)]
return(mean(temp))
}
homerangeoverlapmat[1,1] <- get.props.same(rusIDS)
homerangeoverlapmat[2,2] <- get.props.same(galIDS)
homerangeoverlapmat[3,3] <- get.props.same(lauIDS)
homerangeoverlapmat[4,4] <- get.props.same(cirIDS)
get.props.diff <- function(ids1, ids2){
temp <- c()
k <- 1
mat <- prop_both[is.element(rownames(prop_both), ids1), is.element(colnames(prop_both), ids2)]
for (i in 1:nrow(mat)){
for (j in 1:ncol(mat)){
temp[k] <- mat[i,j]
k <- k + 1
}
}
temp <- temp[!is.nan(temp)]
return(mean(temp))
}
homerangeoverlapmat[1,2] <- get.props.diff(rusIDS, galIDS)
homerangeoverlapmat[1,3] <- get.props.diff(rusIDS, lauIDS)
homerangeoverlapmat[1,4] <- get.props.diff(rusIDS, cirIDS)
homerangeoverlapmat[2,3] <- get.props.diff(galIDS, lauIDS)
homerangeoverlapmat[2,4] <- get.props.diff(galIDS, cirIDS)
homerangeoverlapmat[3,4] <- get.props.diff(lauIDS, cirIDS)
homerangeoverlapmat
}
# -------------------------------------------------------------------------
# linear kernal densities -- modifying some of Matt's code
{
library(magick)
library(plotwidgets)
library(purrr)
library(plotrix)
plot.riverdensity <- function(x, add_background=F, SLDF=NULL, whichplots=NULL,points=TRUE,bycol=TRUE,bylwd=TRUE,maxlwd=10,pwr=0.7,scalebyN=TRUE,ramp="grey",lwd=1,linecol="black",denscol="black",alpha=1,dark=1,showN=TRUE,main=NULL,xlab="",ylab="",add=FALSE,scalebar=TRUE,...) {
if(class(x)!="riverdensity") stop("Argument x must be an object returned from makeriverdensity().")
if(dark>1 | dark<0) dark <-1
if(alpha>1 | alpha<0) alpha <-1
densities <- x$densities
endptverts <- x$endptverts
densverts <- x$densverts
seg <- x$pointsegs
vert <- x$pointverts
survey <- x$survey
if(!is.factor(survey)) survey <- as.factor(survey)
rivers <- x$rivers
if(length(main)==1) main <- rep(main,length(unique(survey)))
# if(is.null(main) & length(unique(survey))>1) main <- sort(unique(as.character(survey)))
if(is.null(main) & length(unique(survey))>1) main <- levels(survey)
lines <- rivers$lines
length <- length(lines)
xmin <- min(lines[[1]][,1])
xmax <- max(lines[[1]][,1])
ymin <- min(lines[[1]][,2])
ymax <- max(lines[[1]][,2])
if(length>1) {
for(j in 2:length) {
if(min(lines[[j]][,1])<xmin) xmin <- min(lines[[j]][,1])
if(max(lines[[j]][,1])>xmax) xmax <- max(lines[[j]][,1])
if(min(lines[[j]][,2])<ymin) ymin <- min(lines[[j]][,2])
if(max(lines[[j]][,2])>ymax) ymax <- max(lines[[j]][,2])
}
}
nsize <- NA
isurvey <- 1
# for(surveyi in sort(unique(survey))) {
for(surveyi in levels(survey)) {
nsize[isurvey] <- length(seg[survey==surveyi])
isurvey <- isurvey+1
}
iisurvey <- 1
if(is.null(whichplots)) whichplots <- 1:length(unique(survey))
# whichplotsurvey <- (sort(unique(survey)))[whichplots]
whichplotsurvey <- (levels(survey))[whichplots]
if(!scalebyN){
isurvey <- 1
# for(surveyi in sort(unique(survey))) {
for(surveyi in levels(survey)) {
for(segi in 1:length(rivers$lines)) {
densities[[isurvey]][[segi]] <- densities[[isurvey]][[segi]]*max(nsize[whichplots])/nsize[isurvey]
}
isurvey <- isurvey+1
}
}
files <- rep(NA, length(whichplotsurvey))
for(surveyi in whichplotsurvey) {
isurvey <- whichplots[iisurvey]
if(showN) mainforplot <- paste0(main[isurvey],"  (n=",length(seg[survey==surveyi]),")")
if(!showN) mainforplot <- main[isurvey]
if(!add){
if (isTRUE(add_background)){
temp<-spTransform(SLDF, CRS("+init=epsg:4326"))
bbox <- temp@bbox
base_map<-OpenStreetMap::openmap(upperLeft=c(bbox[2,2],bbox[1,1]), lowerRight = c(bbox[2,1],bbox[1,2]),
type="bing")
rgb <- base_map$tiles[[1]]$colorData
hsl <- col2hsl(rgb)
hsl[3,] <- hsl[3,]/2.5
base_map$tiles[[1]]$colorData <- hsl2col(hsl)
plot(base_map, removeMargin=F)
x_min <- base_map$bbox$p1[1]
x_max <- base_map$bbox$p2[1]
y_min <- base_map$bbox$p2[2]
y_max <- base_map$bbox$p1[2]
x_mid <- (x_max+x_min)/2
y_diff <- y_max-y_min
if (surveyi=="0"){
text(x=x_mid, y=y_max-y_diff/8, labels=paste("Tagging"), col="yellow", cex=4)
}else{
text(x=x_mid, y=y_max-y_diff/8, labels=paste("Flight", surveyi, sep=" "), col="yellow", cex=4)
}
sldf <- spTransform(sldf, base_map[[1]][[1]]$projection)
base_map[[1]][[1]]$projection
lines(sldf, col="black", lwd=0.1)
}else{
plot(c(xmin,xmax),c(ymin,ymax),col="white",cex.axis=.6,asp=1,xlab=xlab,ylab=ylab,main=mainforplot)
}
}
for(segi in 1:length(rivers$lines)) {
quants <- (densities[[isurvey]][[segi]]/max(unlist(densities)))^pwr
if(bycol) {
if(ramp=="grey" | ramp=="gray") {
cols <- grey((1-quants)*.8)
denscol <- 1
linecol <- grey(.8)
}
if(ramp=="red") {
cols <- rgb(1,(1-quants)*.8,(1-quants)*.8)
denscol <- 2
linecol <- rgb(1,.8,.8)
}
if(ramp=="green") {
cols <- rgb((1-quants)*.8,1,(1-quants)*.8)
denscol <- 3
linecol <- rgb(.8,1,.8)
}
if(ramp=="blue") {
cols <- rgb((1-quants)*.8,(1-quants)*.8,1)
denscol <- 4
linecol <- rgb(.8,.8,1)
}
if(ramp=="heat") {
cols <- heat.colors(1000)[ceiling(900*(1-quants))+1]
denscol <- heat.colors(1000)[1]
linecol <- heat.colors(1000)[901]
}
if(ramp=="stoplight") {
cols <- rainbow(1000)[ceiling(300*(1-quants))+1]
denscol <- rainbow(1000)[1]
linecol <- rainbow(1000)[301]
}
if(ramp=="rainbow") {
cols <- rainbow(1000)[ceiling(700*(1-quants))+1]
denscol <- rainbow(1000)[1]
linecol <- rainbow(1000)[701]
}
}
if(bylwd) {
lwds <- maxlwd*quants
}
if(!bycol) cols <- rep(denscol,(length(endptverts[[segi]])-1))
if(!bylwd) lwds <- rep(lwd,(length(endptverts[[segi]])-1))
if(alpha<1) cols <- adjustcolor(cols,alpha.f=alpha)
if(alpha<1) linecol <- adjustcolor(linecol,alpha.f=alpha)
if(dark<1) cols <- adjustcolor(cols,red.f=dark,green.f=dark,blue.f=dark)
if(dark<1) linecol <- adjustcolor(linecol,red.f=dark,green.f=dark,blue.f=dark)
if(dark<1) denscol <- adjustcolor(denscol,red.f=dark,green.f=dark,blue.f=dark)
for(vertsi in 1:(length(endptverts[[segi]])-1)) {
if(dim(matrix(rivers$lines[[segi]][(endptverts[[segi]][vertsi]):(endptverts[[segi]][vertsi+1]),],ncol=2))[1] > 1) {
lines(rivers$lines[[segi]][(endptverts[[segi]][vertsi]):(endptverts[[segi]][vertsi+1]),],lwd=lwd,col=linecol,lend=1)
if(densities[[isurvey]][[segi]][vertsi] > 0) {
pts <- rivers$lines[[segi]][(endptverts[[segi]][vertsi]):(endptverts[[segi]][vertsi+1]),]
spts <- SpatialPoints(pts, crs(x$rivers$sp))
new_spts <- spTransform(spts, base_map[[1]][[1]]$projection)
lines(new_spts@coords,lwd=lwds[vertsi],col=cols[vertsi],lend=1)
}
}
}
}
if(points) riverpoints(seg=seg[survey==surveyi],vert=vert[survey==surveyi],rivers=rivers,pch=21,bg=0,col=denscol)
si <- as.numeric(surveyi)
file <- paste("S:/Jordy/Yukon River burbot radiotelemetry/plots/plot", si, ".png", sep="")
files[si+1] <- file
dev.print(png, file = file, width = 1024, height = 768)
dev.off()
# if(scalebar) scalebar(rivers)
iisurvey <- iisurvey+1
}
}
riverDensity <- with(allData, makeriverdensity(seg=seg, vert=vert, rivers=riverNetwork, survey=period))
temp <- plot(riverDensity, add_background=T, SLDF=sldf, points=F, ramp="heat", axes=F, maxlwd=15)
files <- c("S:/Jordy/Yukon River burbot radiotelemetry/plots/plot0.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot1.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot2.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot3.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot4.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot5.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot6.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot7.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot8.png",
"S:/Jordy/Yukon River burbot radiotelemetry/plots/plot9.png")
images <- map(files, image_read)
images <- image_join(images)
animation <- image_animate(images, fps = 1)
image_write(animation, "S:/Jordy/Yukon River burbot radiotelemetry/plots/gif.gif")
}
load("D:/Jordy/OpenStreetMaps/sldf.Rdata")
load("D:/Jordy/OpenStreetMaps/allData.Rdata")
load("D:/Jordy/OpenStreetMaps/riverNetwork.Rdata")
??map
