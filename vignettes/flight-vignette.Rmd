---
title: "Processing flight data"
output: rmarkdown::html_vignette

vignette: >
  %\VignetteIndexEntry{Put the title of your vignette here}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(telprep)
library(rlist)
```

This vignette will show you how the telprep package can be used to automatically process data from telemetry flights. The program is designed to read in raw txt files, filter out erroneous signals, and determine the living status of fish. This tutorial is designed to highlight the general workflow of the program. For a more detailed description of the program functionalities, see the help files for the following functions: read.flight.data, channels.merge, replace.date, combine.data, get.best.locations, flag.dead.fish, and add.to.database.


### Program Workflow:
* Step 1 -- Read raw data into R 
* Step 2 -- If channels or dates were misprogrammed, make corrections
* Step 3 -- Combine the folder contents 
* Step 4 -- Determine the best signal/locations and flag for erroneous signals
* Step 5 -- Determine the living status of the fish
* Step 6 -- Add the results to an existing database


### Step 1 -- Read raw data into R
Begin by sticking the raw txt files into a folder. Txt files from multiple flights can be added to folder. The names should be easily recognized as they will be used later on. Find the path of the folder (on my system, the path is D:/Jordy/telprep/telprep2/data/) and use the read.flight.data function to read the relevant information into R:

```{r echo=TRUE}
folder_path <- "C:/Users/19708/Desktop/data/"
raw_data <- read.flight.data(folder_path) # call help("read.flight.data") for a more detailed description of the function the associated arguments
```
The raw data is now stored in the variable "raw_data". To see how it is organized, call
```{r}
names(raw_data)
```
Here, "tburb_f1_1-26-19-WING.TXT" is listed 2nd. To see the data from this file, call "raw_data[[2]]".  

### Step 2 -- If channels or dates were misprogrammed, make corrections
If a channel or date was misprogrammed, it needs to be corrected before the raw data is combined. As an example, we will suppose that channel 3 was misprogrammed as channel 10 in "tburb_f1_1-26-19-WING.TXT". To peek at the data we can call
```{r}
head(raw_data[[2]])
```
The channel can now be corrected using the code
```{r}
raw_data[[2]] <- channels.merge(raw_data[[2]], 10, 3)
head(raw_data[[2]])
```







If a date was misprogramed, use the code
```{r}
head(raw_data[[16]]) # 2003 ?
raw_data[[16]] <- replace.date(raw_data[[16]], new_date ="04/25/19") # see help(replace.date)?
head(raw_data[[16]])
```

### Step 3 -- Combine the contents of the data in the folder
The next step is to combine the contents of the data using the function combine.data. Before combining the file contents, the source of the file must be determined (i.e. was the receiver on the belly or wing of the aircraft). To combine the contents into a variable named all_data, run the following lines:

```{r}
head(names(raw_data)) # to determine source_vec
source_vec <- c(rep(c("belly","wing"), 10), rep(c("wing","belly"),2), c("belly","wing"))
all_data <- combine.data(raw_data, source_vec) # See help(combine.data)
```

### Step 4 -- Determine the best locations and flag false detections
Now that the raw data has been combined, the best location will be determined and erroneous detections will be flagged using the function get.best.locations:
```{r message=FALSE}
best_locations <- get.best.locations(all_data, bin_by = 1, n_thresh = 5, dist_max = 10, remove_flagged = F) # See help(process_data)
all_detects <- best_locations$all_detects
best_detects <- best_locations$best_detects
```
```{r}
head(all_detects)
head(best_detects)
```
Here, all_detects adds some useful to all_data:  all_detects\$BestSignal is the signal with the highest power in a detection period, all_detects\$Dist is the geodesic distance (in km) between the detection location and the associated highest power detection, and all_detects\$Records is number of times that a fish was detected in a detection period. The argument bin_by can be used to adjust the length of the detection period. 

best_detects contains the highest power detections. A best detection will be flagged if there are fewer than n_thresh other detections within a distance of dist_max km from the best detection during the detection period. The best detection will also be flagged if a negative linear relationship does not exist between all_detects\$Power and all_detects\$Dist for all detections within dist_max km from the best signal in the detection period. This information is summarized in best_detects. To remove the flagged detection, set removed_flagged=T.

### Step 5 -- Determine the living status of the fish
To flag for dead fish run the following lines of code:
```{r}
best_detects <- best_detects[!best_detects$flag,] # To remove the flagged fish
flagged_fish <- flag.dead.fish(best_detects, dist_thresh = 5) # To flag for mortality
head(flagged_fish)
```
Here, a recursive algorithm is used to determine whether or not a fish is alive. Basically, if a fish moves less than dist_thresh km for all consecutive detection periods following the detection, the fish will be flagged as dead. Geodesic distance is currently used to screen for dead fish.

### Step 6 -- Add the results to an existing database
To add the results to an existing database, find the filepath of your database and run the code
```{r}
# filepath <- "D:/Jordy/telprep/telprep2/data/database.csv"
# add.to.database(filepath, flagged_fish)
```






