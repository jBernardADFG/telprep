---
title: "flight-vignette"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(telprep)
library(rlist)
```

This vignette will show you how the telprep package can be used to automatically process data from telemetry flights. The program is designed to read in raw txt files, filter out erroneous signals, and determine the living status of fish. This tutorial is designed to highlight the general workflow of the program. For a more detailed description of the program functionalities, see the help files for the following functions: read.flight.data, channels.merge, replace.date, combine.data, get.date.bins, get.best.locations, flag.dead.fish, and add.to.database.


### Program Workflow:
* Step 1 -- Read raw data into R 
* Step 2 -- If channels or dates were misprogrammed, make corrections
* Step 3 -- Combine the folder contents 
* Step 4 -- Determine the best locations and flag for erroneous signals
* Step 5 -- Determine the living status of the fish
* Step 6 -- Add the results to an existing database


### Step 1 -- Read raw data into R
Begin by sticking the raw txt files into a folder. Txt files from multiple flights can be added to the folder. The names should be easily recognized as they will be used later on. It may be helpful to specify the flight grouping, flight date, and the receiver location in the file names for quick reference later on (eg f1_1-26-19_BELLY.TXT). Find the path of the folder (on my system, the path is D:/Jordy/telprep/telprep2/data/) and use the read.flight.data function to read the relevant information into R:

```{r}
folder_path <- "C:/Users/19708/Desktop/data/"
raw_data <- read.flight.data(folder_path)
```
The raw data is now stored in the variable raw_data. The following line of code can be run to see how the data is organized internally:
```{r}
names(raw_data)
```
Here, "tburb_f1_1-26-19-WING.TXT" is listed 2nd. To see the data from this file, run raw_data[[2]].  

### Step 2 -- If channels or dates were misprogrammed, make corrections
If a channel or date was misprogrammed, it needs to be corrected before the raw data is combined. As an example, we will suppose that channel 3 was misprogrammed as channel 10 in "tburb_f1_1-26-19-WING.TXT". To peek at the data we can run
```{r}
head(raw_data[[2]])
```
The misprogrammed channel will be fixed with the following line of code:
```{r}
raw_data[[2]] <- channels.merge(raw_data[[2]], 10, 3)
head(raw_data[[2]])
```
We will now suppose that a date was misprogrammed in the file "tburb_f5_10-17-19-WING.TXT" and the file "tburb_f5_10-7-19-WING.TXT". To peek at the data, run 
```{r}
head(raw_data[[16]])
head(raw_data[[18]])
```
If the correct flights dates were "10/17/19" and "10/7/19", the following lines of code will make the corrections:
```{r}
raw_data[[16]] <- replace.date(raw_data[[16]], new_date ="10/17/19") 
head(raw_data[[16]])
raw_data[[18]] <- replace.date(raw_data[[18]], new_date ="10/7/19") 
head(raw_data[[18]])
```

### Step 3 -- Combine the contents of the data in the folder
The function combine.data combines the data in raw_data into a single data.frame. An argument (source_vec) is provided so that the source of each txt file can be specified (i.e. does the txt file come from a receiver on the belly or the wing of the aircraft). Because 26 txt files were contained in the example folder ("C:/Users/19708/Desktop/data/"), a vector of length 26 is needed to incode this information. To determine the source of each data.frame in raw_data, we can run names(raw_data) to assist in the construction of source_vec:

```{r}
names(raw_data)
source_vec <- c(rep(c("belly","wing"), 10), rep(c("wing","belly"),2), c("belly","wing"))
source_vec
```
Now that the source of the data has been specified, we can use the function combine.data to combine the contents of raw_data:
```{r}
all_data <- combine.data(raw_data, source_vec)
head(all_data)
```
### Step 4: Determine the best locations and flag for erroneous signals
The best location will now be determined and erroneous detections will be flagged using the function get.best.locations. In short, the best location is considered to be the location where the highest power detection occurred for each fish in each detection period. Two arguments can be used to specify the detection periods: date_bins allows the user to manually specify each detection period whereas bin_by allows the user to specify the length (in days) of the detection period. An overview of the manual approach is provided here.

To assist in the construction date_bins, we can run the following line of code to look up the flight grouping:
```{r}
names(raw_data)
```
After constructing a vector flight_group to incode the flight grouping, we can used the function get.date.bins to get the appropriate detection periods. 
```{r}
flight_group <- c(1,1,1,1,2,2,2,2,3,3,3,3,4,4,5,5,5,5,6,6,7,7,7,7,8,8)
date_bins <- get.date.bins(raw_data, flight_group)
date_bins
```
Now, we use the function get.best.locations to determine the best locations and flag for false detections:
```{r echo = T, results = 'hide'}
best_locations <- get.best.locations(all_data, date_bins =  date_bins, bin_by=NA, n_thresh = 5, dist_max = 10, remove_flagged = F)
```
```{r}
head(best_locations$all_detects)
head(best_locations$best_detects)
```

best_locations\$all_detects adds some useful to all_data: BestSignal is the signal with the highest power in a detection period, Dist is the geodesic distance (in km) between the detection location and the associated highest power detection, FlightNum is the detection period, and Records is number of times that a fish was detected in a detection period.

all_detects\$best_detects contains the highest power detections only. A best detection will be flagged if there are fewer than n_thresh detections within a distance of dist_max km from the best detection during the detection period. The best detection will also be flagged if a positive linear relationship exists between Power and Dist for all detections within dist_max km from the best signal in the detection period (i.e. the signal strength increases as the best detection is approached). This information is summarized in best_detects. To remove the flagged detection in all_detects\$best_detects, set removed_flagged=T.

### Step 5 -- Determine the living status of the fish
The function flag.dead.fish can be used to determine the living status of fish: 

```{r}
best_detects <- best_locations$best_detects
best_detects <- best_detects[!best_detects$flag,] # To remove the flagged fish
flagged_fish <- flag.dead.fish(best_detects, dist_thresh = 5)
flagged_fish[c(600:605),]
```
Here, a recursive algorithm is used to make the determination. Basically, if a fish moves less than dist_thresh km for all consecutive detection periods following a detection, the fish will be flagged as dead. Geodesic distance is currently used to screen for dead fish, and mortality signal information is not taken into account -- be sure to download the latest package version as updates will be made.

### Step 6 -- Add the results to an existing database
To add the results to an existing database, find the filepath of your database and run the code
```{r}
# filepath <- "C:/Users/19708/Desktop/database.csv"
# add.to.database(filepath, flagged_fish)
```
